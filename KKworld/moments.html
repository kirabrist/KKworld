<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>动态</title>
    <link rel="stylesheet" href="qq_lobby_style.css">
    <link rel="stylesheet" href="moments_style.css">
</head>
<body>
<div class="qq-container moments-page">
    <main class="moments-content">
        <header class="moments-header">
            <div id="banner-container" class="banner-container">
                <img id="banner-image" src="images/default_banner.jpg" alt="动态封面">
                <input type="file" id="banner-uploader" accept="image/*" style="display:none;">
            </div>
            <div class="header-actions">
                <button id="refresh-moments-btn" class="header-action-btn"><img src="images/refresh_icon.svg" alt="刷新动态"></button>
            </div>
            <div class="user-profile-summary">
                <img id="profile-avatar" class="profile-avatar" src="images/default_avatar.png" alt="用户头像">
                <span id="profile-nickname" class="profile-nickname"></span>
            </div>
        </header>
        <section id="posts-feed" class="posts-feed"></section>
    </main>
    <button id="create-moment-fab" class="fab">+</button>
    <footer class="bottom-nav">
        <a href="chat.html" class="nav-item">消息</a><a href="channels.html" class="nav-item">频道</a><a href="contacts.html" class="nav-item">联系人</a><a href="moments.html" class="nav-item active">动态</a>
    </footer>
    <div id="create-moment-modal" class="moment-modal-container">
        <div class="modal-content-wrapper">
            <header class="modal-top-bar"><button id="cancel-moment-btn" class="modal-button">取消</button><h2 class="modal-title">写说说</h2><button id="publish-moment-btn" class="modal-button publish-btn" disabled>发表</button></header>
            <main class="modal-body-content"><textarea id="moment-text-input" placeholder="分享新鲜事..."></textarea><div class="moment-image-preview-container" id="moment-image-preview-container"></div></main>
            <footer class="modal-toolbar"><button id="add-image-tool-btn"><img src="images/image_placeholder_icon.svg"></button><input type="file" id="moment-image-uploader" multiple accept="image/*" style="display:none;"></footer>
        </div>
    </div>
</div>
<script>
document.addEventListener('DOMContentLoaded', () => {
    const bannerContainer = document.getElementById('banner-container');
    const bannerImage = document.getElementById('banner-image');
    const bannerUploader = document.getElementById('banner-uploader');
    const profileAvatar = document.getElementById('profile-avatar');
    const profileNickname = document.getElementById('profile-nickname');
    const createMomentFab = document.getElementById('create-moment-fab');
    const createMomentModal = document.getElementById('create-moment-modal');
    const cancelMomentBtn = document.getElementById('cancel-moment-btn');
    const publishMomentBtn = document.getElementById('publish-moment-btn');
    const momentTextInput = document.getElementById('moment-text-input');
    const addImageToolBtn = document.getElementById('add-image-tool-btn');
    const momentImageUploader = document.getElementById('moment-image-uploader');
    const imagePreviewContainer = document.getElementById('moment-image-preview-container');
    const postsFeed = document.getElementById('posts-feed');
    const refreshMomentsBtn = document.getElementById('refresh-moments-btn');
    let newMomentImages = [];

    function loadProfileInfo() { profileAvatar.src = localStorage.getItem('userAvatar') || 'images/default_avatar.png'; profileNickname.textContent = localStorage.getItem('userNickname') || '未设置昵称'; bannerImage.src = localStorage.getItem('momentsBanner') || 'images/default_banner.jpg'; }
    function showModal(modal) { modal.classList.add('show'); }
    function hideModal(modal) { modal.classList.remove('show'); }
    function resetCreateModal() { momentTextInput.value = ''; imagePreviewContainer.innerHTML = ''; newMomentImages = []; publishMomentBtn.disabled = true; }
    function validatePublishButton() { const hasText = momentTextInput.value.trim() !== ''; const hasImages = newMomentImages.length > 0; publishMomentBtn.disabled = !hasText && !hasImages; }
    function createReplyInput(postId, parentCommentId, parentAuthorName, targetElement) { const existingReplyInput = document.querySelector('.reply-input-wrapper'); if (existingReplyInput) existingReplyInput.remove(); const replyWrapper = document.createElement('div'); replyWrapper.className = 'comment-input-wrapper reply-input-wrapper'; replyWrapper.innerHTML = `<input type="text" class="comment-input" placeholder="回复 ${parentAuthorName}..." data-post-id="${postId}" data-parent-comment-id="${parentCommentId}" data-parent-author-name="${parentAuthorName}">`; targetElement.insertAdjacentElement('afterend', replyWrapper); replyWrapper.querySelector('input').focus(); }
    function renderReplies(comments, postId) { let repliesHtml = ''; const characterMap = { 'user_self': { id: 'user_self', nickname: localStorage.getItem('userNickname') || '我', avatar: localStorage.getItem('userAvatar') || 'images/default_avatar.png' } }; (JSON.parse(localStorage.getItem('friends')) || []).forEach(f => { characterMap[f.id] = f; }); comments.forEach(comment => { const author = characterMap[comment.authorId] || { nickname: '未知用户' }; repliesHtml += `<div class="comment-item reply-item" data-comment-id="${comment.id}"><p><strong class="comment-author">${author.nickname}</strong>${comment.replyTo ? ` 回复 <strong class="comment-author">${(characterMap[comment.replyTo] || {nickname:'未知用户'}).nickname}</strong>` : ''}: ${comment.text}</p>${renderReplies(comment.replies || [], postId)}</div>`; }); return repliesHtml ? `<div class="reply-container">${repliesHtml}</div>` : ''; }
    function renderPosts() {
        const posts = JSON.parse(localStorage.getItem('momentsPosts')) || [];
        const characterMap = { 'user_self': { id: 'user_self', nickname: localStorage.getItem('userNickname') || '我', avatar: localStorage.getItem('userAvatar') || 'images/default_avatar.png' } };
        (JSON.parse(localStorage.getItem('friends')) || []).forEach(f => { characterMap[f.id] = f; });
        postsFeed.innerHTML = '';
        if (posts.length === 0) { postsFeed.innerHTML = '<p class="empty-message" style="margin-top:20px;">还没有任何动态</p>'; return; }
        posts.forEach(post => {
            const postElement = document.createElement('div'); postElement.className = 'post-card'; postElement.dataset.postId = post.id;
            const author = characterMap[post.authorId] || { nickname: '未知用户', avatar: 'images/default_avatar.png' };
            const timestamp = new Date(post.timestamp); const month = timestamp.getMonth() + 1, day = timestamp.getDate(), hours = String(timestamp.getHours()).padStart(2, '0'), minutes = String(timestamp.getMinutes()).padStart(2, '0'); const timeString = `${month}月${day}日 ${hours}:${minutes}`;
            let imagesHtml = '';
            if(post.images && post.images.length > 0) {
                post.images.forEach(imgData => {
                    if (typeof imgData === 'string') { imagesHtml += `<div class="post-image-item" style="background-image: url('${imgData}')"></div>`; }
                    else if (imgData.type === 'ai_generated') { imagesHtml += `<div class="post-image-item ai-image-placeholder"><span>${imgData.description}</span></div>`; }
                });
            }
            let likesHtml = '';
            if (post.likes.length > 0) { likesHtml = `<div class="like-section"><img src="images/like_icon.svg" class="like-section-icon">${post.likes.slice(0, 5).map(id => (characterMap[id] || { nickname: '未知用户' }).nickname).join('、')}${post.likes.length > 5 ? ` 等${post.likes.length}人` : ''}</div>`; }
            let commentsHtml = '';
            (post.comments || []).forEach(comment => { const commentAuthor = characterMap[comment.authorId] || { nickname: '未知用户' }; commentsHtml += `<div class="comment-item" data-comment-id="${comment.id}"><p><strong class="comment-author">${commentAuthor.nickname}:</strong> ${comment.text}</p>${renderReplies(comment.replies || [], post.id)}</div>`; });
            const isLiked = post.likes.includes('user_self');
            postElement.innerHTML = `
                <div class="post-header"><img src="${author.avatar}" class="author-avatar"><div class="author-info"><strong class="author-name">${author.nickname}</strong><span class="post-timestamp">${timeString}</span></div></div>
                <div class="post-content">${post.text}</div>
                <div class="post-image-grid style-img-count-${(post.images || []).length}">${imagesHtml}</div>
                <div class="post-actions"><button class="action-btn like-btn ${isLiked ? 'liked' : ''}" data-action="like"><img src="images/like_icon.svg"><span>${isLiked ? '已赞' : '赞'}</span></button><button class="action-btn" data-action="comment"><img src="images/comment_icon.svg"><span>评论</span></button><button class="action-btn share-btn" data-action="share"><img src="images/share_icon.svg"><span>转发</span></button></div>
                ${likesHtml}<div class="comment-section">${commentsHtml}<div class="comment-input-wrapper"><input type="text" class="comment-input" placeholder="说点什么..." data-post-id="${post.id}" data-parent-comment-id="root"></div></div>`;
            postsFeed.appendChild(postElement);
        });
    }

    function resizeAndCompressImage(imageSrc, maxSize = 512, quality = 0.7) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                let width = img.width, height = img.height;
                if (width > height) {
                    if (width > maxSize) { height *= maxSize / width; width = maxSize; }
                } else {
                    if (height > maxSize) { width *= maxSize / height; height = maxSize; }
                }
                canvas.width = width; canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                resolve(canvas.toDataURL('image/jpeg', quality));
            };
            img.onerror = reject;
            img.src = imageSrc;
        });
    }

    async function triggerAIMomentsInteraction() {
        refreshMomentsBtn.classList.add('loading');
        refreshMomentsBtn.disabled = true;

        const proxy = localStorage.getItem('hakimi-os-proxy');
        let apiEndpoint = localStorage.getItem('hakimi-os-api-endpoint');
        const apiKey = localStorage.getItem('hakimi-os-api-key');
        const apiModel = localStorage.getItem('hakimi-os-api-model');
        const systemPrompt = localStorage.getItem('hakimi-os-system-prompt');

        if (!apiKey || !apiEndpoint || !apiModel) {
            alert('请先在主屏幕设置中配置AI');
            refreshMomentsBtn.classList.remove('loading');
            refreshMomentsBtn.disabled = false;
            return;
        }

        const allFriends = JSON.parse(localStorage.getItem('friends')) || [];
        const allPosts = JSON.parse(localStorage.getItem('momentsPosts')) || [];
        const threeDaysAgo = Date.now() - 3 * 24 * 60 * 60 * 1000;
        
        const recentUserPosts = allPosts.filter(p => p.authorId === 'user_self' && new Date(p.timestamp).getTime() > threeDaysAgo);

        if (recentUserPosts.length === 0) {
            console.log("没有最近的用户帖子可供AI互动。");
            refreshMomentsBtn.classList.remove('loading');
            refreshMomentsBtn.disabled = false;
            return;
        }

        const latestPost = recentUserPosts[0];

        const visibleFriends = allFriends.filter(f => 
            !latestPost.permissions || latestPost.permissions.type === 'public' ? 
            !(latestPost.permissions.excluded_ids || []).includes(f.id) : 
            (latestPost.permissions.included_ids || []).includes(f.id)
        );

        const simplifiedPost = {
            id: latestPost.id,
            authorId: latestPost.authorId,
            text: latestPost.text,
            image_count: (latestPost.images || []).length, 
            comments: latestPost.comments || []
        };

        const simplifiedFriends = visibleFriends.map(f => ({
            id: f.id,
            name: f.name,
            nickname: f.nickname,
            prompt: f.prompt // **绝对不发送头像**
        }));

        const contextData = {
            moments_context: {
                posts: [simplifiedPost],
                friends: simplifiedFriends
            }
        };
        
        const userContent = [{ type: 'text', text: JSON.stringify(contextData) }];

        if (latestPost.images && latestPost.images.length > 0) {
            const latestImageSrc = latestPost.images[0]; // 只取第一张作为代表
            if (typeof latestImageSrc === 'string' && latestImageSrc.startsWith('data:image')) {
                try {
                    console.log("正在压缩图片给AI...");
                    const compressedDataUrl = await resizeAndCompressImage(latestImageSrc);
                    userContent.push({ type: 'image_url', image_url: { url: compressedDataUrl } });
                    console.log("图片压缩完成！");
                } catch (e) {
                    console.error('图片压缩失败，本次将不发送图片给AI', e);
                }
            }
        }

        const messages = [{ role: 'system', content: systemPrompt }, { role: 'user', content: userContent }];

        try {
            if (!apiEndpoint.endsWith('/chat/completions')) {
                apiEndpoint = apiEndpoint.replace(/\/$/, '') + '/chat/completions';
            }
            const response = await fetch(proxy + encodeURIComponent(apiEndpoint), {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: apiModel,
                    messages: messages,
                    max_tokens: 1024,
                    response_format: { type: "json_object" }
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }

            const result = await response.json();
            const content = result.choices[0].message.content;
            
            if (!content) throw new Error('AI返回的响应内容为空');

            const jsonText = content.replace(/```json/g, '').replace(/```/g, '').trim();
            
            try {
                const aiData = JSON.parse(jsonText);
                if (aiData && Array.isArray(aiData.actions)) {
                    applyAIActions(aiData.actions);
                } else {
                    throw new Error('解析后的JSON中缺少 "actions" 数组');
                }
            } catch (e) {
                console.error('AI返回的JSON解析失败:', jsonText, e);
                alert('AI返回了无法解析的格式，请检查控制台以获取详细信息。');
            }
        } catch (error) {
            alert('AI交互失败: ' + error.message);
        } finally {
            refreshMomentsBtn.classList.remove('loading');
            refreshMomentsBtn.disabled = false;
        }
    }

    function applyAIActions(actions) {
        if (!Array.isArray(actions)) return;
        const posts = JSON.parse(localStorage.getItem('momentsPosts')) || [];
        actions.forEach(action => {
            const post = posts.find(p => p.id === action.postId); if (!post) return;
            switch (action.action) {
                case 'like': if (!post.likes.includes(action.characterId)) { post.likes.push(action.characterId); } break;
                case 'comment': { const newComment = { id: `comment_${Date.now()}_${Math.random()}`, authorId: action.characterId, text: action.text, timestamp: new Date().toISOString(), replies: [] }; if(!post.comments) post.comments = []; post.comments.push(newComment); break; }
                case 'reply': {
                    const findComment = (comments, commentId) => { for (const c of comments) { if (c.id === commentId) return c; const found = findComment(c.replies || [], commentId); if (found) return found; } return null; };
                    const parentComment = findComment(post.comments, action.commentId);
                    if (parentComment) { const newReply = { id: `comment_${Date.now()}_${Math.random()}`, authorId: action.characterId, text: action.text, timestamp: new Date().toISOString(), replyTo: parentComment.authorId, replies: [] }; if(!parentComment.replies) parentComment.replies = []; parentComment.replies.push(newReply); }
                    break;
                }
            }
        });
        localStorage.setItem('momentsPosts', JSON.stringify(posts));
        renderPosts();
    }
    
    bannerContainer.addEventListener('click', () => bannerUploader.click());
    bannerUploader.addEventListener('change', (e) => { const file = e.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { bannerImage.src = e.target.result; localStorage.setItem('momentsBanner', e.target.result); }; reader.readAsDataURL(file); } });
    createMomentFab.addEventListener('click', () => showModal(createMomentModal));
    cancelMomentBtn.addEventListener('click', () => { hideModal(createMomentModal); resetCreateModal(); });
    momentTextInput.addEventListener('input', validatePublishButton);
    addImageToolBtn.addEventListener('click', () => momentImageUploader.click());
    momentImageUploader.addEventListener('change', (e) => {
        const files = Array.from(e.target.files); imagePreviewContainer.innerHTML = ''; newMomentImages = [];
        files.forEach(file => { const reader = new FileReader(); reader.onload = (e) => { newMomentImages.push(e.target.result); const preview = document.createElement('div'); preview.className = 'image-preview-item'; preview.style.backgroundImage = `url(${e.target.result})`; imagePreviewContainer.appendChild(preview); validatePublishButton(); }; reader.readAsDataURL(file); });
        momentImageUploader.value = '';
    });
    publishMomentBtn.addEventListener('click', () => {
        const newPost = { id: `moment_${Date.now()}`, authorId: 'user_self', text: momentTextInput.value.trim(), images: newMomentImages, permissions: { type: 'public', excluded_ids: [] }, timestamp: new Date().toISOString(), likes: [], comments: [] };
        const posts = JSON.parse(localStorage.getItem('momentsPosts')) || []; posts.unshift(newPost);
        localStorage.setItem('momentsPosts', JSON.stringify(posts));
        renderPosts(); hideModal(createMomentModal); resetCreateModal();
    });
    postsFeed.addEventListener('click', (e) => {
        const actionBtn = e.target.closest('.action-btn');
        if (actionBtn) {
            const postId = actionBtn.closest('.post-card').dataset.postId; const action = actionBtn.dataset.action;
            if (action === 'like') { const posts = JSON.parse(localStorage.getItem('momentsPosts')) || []; const post = posts.find(p => p.id === postId); if (post) { const userLikeIndex = post.likes.indexOf('user_self'); if (userLikeIndex > -1) { post.likes.splice(userLikeIndex, 1); } else { post.likes.push('user_self'); } localStorage.setItem('momentsPosts', JSON.stringify(posts)); renderPosts(); } }
            else if (action === 'comment') { const input = actionBtn.closest('.post-card').querySelector('.comment-input-wrapper input[data-parent-comment-id="root"]'); if (input) input.focus(); }
        } else {
            const commentItem = e.target.closest('.comment-item');
            if (commentItem) {
                const postId = commentItem.closest('.post-card').dataset.postId; const commentId = commentItem.dataset.commentId; const authorName = commentItem.querySelector('.comment-author').textContent.replace(':', '');
                createReplyInput(postId, commentId, authorName, commentItem);
            }
        }
    });
    postsFeed.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && e.target.classList.contains('comment-input')) {
            const text = e.target.value.trim(); if (!text) return;
            const postId = e.target.dataset.postId, parentCommentId = e.target.dataset.parentCommentId;
            const posts = JSON.parse(localStorage.getItem('momentsPosts')) || [];
            const post = posts.find(p => p.id === postId);
            if (post) {
                if (parentCommentId === 'root') { const newComment = { id: `comment_${Date.now()}_${Math.random()}`, authorId: 'user_self', text: text, timestamp: new Date().toISOString(), replies: [] }; if(!post.comments) post.comments = []; post.comments.push(newComment); }
                else {
                    const findComment = (comments, cId) => { for (const c of comments) { if (c.id === cId) return c; const found = findComment(c.replies || [], cId); if (found) return found; } return null; };
                    const parentComment = findComment(post.comments, parentCommentId);
                    if (parentComment) { const newReply = { id: `comment_${Date.now()}_${Math.random()}`, authorId: 'user_self', text: text, timestamp: new Date().toISOString(), replyTo: parentComment.authorId, replies: [] }; if(!parentComment.replies) parentComment.replies = []; parentComment.replies.push(newReply); }
                }
            }
            localStorage.setItem('momentsPosts', JSON.stringify(posts));
            renderPosts();
        }
    });
    refreshMomentsBtn.addEventListener('click', triggerAIMomentsInteraction);
    loadProfileInfo(); renderPosts();
});
</script>
</body>
</html>