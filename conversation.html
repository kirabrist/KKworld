<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>èŠå¤©</title>
    <link rel="stylesheet" href="conversation_style.css">
</head>
<body>
<div class="chat-container">
    <header class="header">
        <a href="chat.html" class="back-button"><</a>
        <div class="friend-info">
            <span id="friend-name" class="name">åŠ è½½ä¸­...</span>
            <span id="status-indicator" class="status">ğŸŸ¢ åœ¨çº¿</span>
        </div>
        <img id="regenerate-btn" src="images/refresh_icon.svg" class="more-options" alt="é‡æ–°ç”Ÿæˆå›å¤" title="é‡æ–°ç”ŸæˆAIçš„æœ€æ–°å›å¤">
    </header>
    <main id="message-area" class="message-area"></main>
    <div class="input-area">
        <div id="reply-preview" class="reply-preview">
            <div id="reply-preview-content"></div>
            <button id="close-reply-preview">Ã—</button>
        </div>
        <textarea id="message-input" placeholder="è¾“å…¥æ¶ˆæ¯..." rows="1"></textarea>
        <button id="transmit-button" title="å‘é€ç»™AIè¿›è¡Œå›å¤"><img src="images/transmit_icon.svg" alt="ä¼ è¾“"></button>
        <button id="send-button">å‘é€</button>
    </div>
    <footer class="action-bar">
        <img id="voice-message-btn" src="images/mic_icon.svg" alt="è¯­éŸ³"><img id="image-message-btn" src="images/image_icon.svg" alt="å›¾ç‰‡"><img id="camera-message-btn" src="images/camera_icon.svg" alt="ç›¸æœº"><img id="transfer-btn" src="images/wallet_icon.svg" alt="è½¬è´¦"><img id="emoji-btn" src="images/emoji_icon.svg" alt="è¡¨æƒ…"><img id="plus-icon" src="images/plus_icon.svg" alt="æ›´å¤šåŠŸèƒ½">
    </footer>
    <div id="sticker-panel" class="sticker-panel">
        <div class="sticker-panel-header"><span>è¡¨æƒ…åŒ…</span><div><button id="add-sticker-btn">æ·»åŠ </button> <button id="close-sticker-panel-btn">å…³é—­</button></div></div>
        <div id="sticker-grid" class="sticker-grid"></div>
    </div>
    <input type="file" id="image-uploader" accept="image/*" style="display: none;">
    <input type="file" id="sticker-uploader" accept="image/*" style="display: none;">
    <div id="transfer-modal" class="modal-overlay">
        <div class="modal-content"><h2 id="transfer-title">è½¬è´¦</h2><div class="transfer-form-group"><label for="transfer-amount-input">è½¬è´¦é‡‘é¢</label><input type="number" id="transfer-amount-input" placeholder="0.00" step="0.01"><div id="transfer-error" class="error-message"></div></div><div class="transfer-form-group"><label for="transfer-remark-input">å¤‡æ³¨ (æœ€å¤š20å­—)</label><input type="text" id="transfer-remark-input" maxlength="20"></div><div class="modal-actions"><button id="cancel-transfer-btn">å–æ¶ˆ</button><button id="confirm-transfer-btn" disabled>è½¬è´¦</button></div></div>
    </div>
    <div id="message-context-menu" class="context-menu">
        <div id="reply-message-btn" class="context-menu-item">å¼•ç”¨</div>
        <div id="edit-message-btn" class="context-menu-item">ç¼–è¾‘</div>
        <div id="delete-message-btn" class="context-menu-item">åˆ é™¤</div>
    </div>
</div>
<script>
    (function() {
        const friendNameElement = document.getElementById('friend-name');
        const statusIndicator = document.getElementById('status-indicator');
        const messageArea = document.getElementById('message-area');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const transmitButton = document.getElementById('transmit-button');
        const voiceMessageBtn = document.getElementById('voice-message-btn');
        const imageMessageBtn = document.getElementById('image-message-btn');
        const cameraMessageBtn = document.getElementById('camera-message-btn');
        const imageUploader = document.getElementById('image-uploader');
        const transferBtn  = document.getElementById('transfer-btn');
        const transferModal = document.getElementById('transfer-modal');
        const transferTitle = document.getElementById('transfer-title');
        const transferAmountInput = document.getElementById('transfer-amount-input');
        const transferRemarkInput = document.getElementById('transfer-remark-input');
        const confirmTransferBtn = document.getElementById('confirm-transfer-btn');
        const cancelTransferBtn = document.getElementById('cancel-transfer-btn');
        const transferError = document.getElementById('transfer-error');
        const emojiBtn = document.getElementById('emoji-btn');
        const stickerPanel = document.getElementById('sticker-panel');
        const stickerGrid = document.getElementById('sticker-grid');
        const addStickerBtn = document.getElementById('add-sticker-btn');
        const closeStickerPanelBtn = document.getElementById('close-sticker-panel-btn');
        const stickerUploader = document.getElementById('sticker-uploader');
        const contextMenu = document.getElementById('message-context-menu');
        const replyBtn = document.getElementById('reply-message-btn');
        const editBtn = document.getElementById('edit-message-btn');
        const deleteBtn = document.getElementById('delete-message-btn');
        const regenerateBtn = document.getElementById('regenerate-btn');
        const replyPreview = document.getElementById('reply-preview');
        const replyPreviewContent = document.getElementById('reply-preview-content');
        const closeReplyPreviewBtn = document.getElementById('close-reply-preview');

        let friendData = {}; let userData = {}; let friendId = null; let userStickers = [];
        let lastMessageTimestamp = 0; const TEN_MINUTES_IN_MS = 10 * 60 * 1000;
        let longPressTimer; let activeMessageId = null; let activeMessageElement = null;
        let replyingToMessageId = null;

        const DBHelper = {
            db: null,
            openDB: function() { return new Promise((resolve, reject) => { if (this.db) { return resolve(this.db); } const request = indexedDB.open('ChatDatabase', 2); request.onerror = (event) => reject("æ•°æ®åº“é”™è¯¯: " + event.target.errorCode); request.onsuccess = (event) => { this.db = event.target.result; resolve(this.db); }; request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains('conversations')) { const store = db.createObjectStore('conversations', { keyPath: 'id', autoIncrement: true }); store.createIndex('conversationId', 'conversationId', { unique: false }); }}; }); },
            addMessage: async function(conversationId, message) { const db = await this.openDB(); return new Promise((resolve, reject) => { const transaction = db.transaction(['conversations'], 'readwrite'); const store = transaction.objectStore('conversations'); message.conversationId = conversationId; const request = store.add(message); request.onsuccess = (event) => { message.id = event.target.result; resolve(message); }; request.onerror = (event) => reject("æ·»åŠ æ¶ˆæ¯å¤±è´¥: " + event.target.error); }); },
            getMessages: async function(conversationId) { const db = await this.openDB(); return new Promise((resolve, reject) => { const transaction = db.transaction(['conversations'], 'readonly'); const store = transaction.objectStore('conversations'); const index = store.index('conversationId'); const request = index.getAll(conversationId); request.onsuccess = () => resolve(request.result.sort((a,b) => a.timestamp - b.timestamp)); request.onerror = (event) => reject("è·å–æ¶ˆæ¯å¤±è´¥: " + event.target.error); }); },
            getMessageById: async function(id) { const db = await this.openDB(); return new Promise((resolve, reject) => { const transaction = db.transaction(['conversations'], 'readonly'); const store = transaction.objectStore('conversations'); const request = store.get(id); request.onsuccess = () => resolve(request.result); request.onerror = reject; }); },
            deleteMessage: async function(id) { const db = await this.openDB(); return new Promise((resolve, reject) => { const transaction = db.transaction(['conversations'], 'readwrite'); const store = transaction.objectStore('conversations'); const request = store.delete(id); request.onsuccess = resolve; request.onerror = reject; }); },
            updateMessageContent: async function(id, newContent) { const db = await this.openDB(); return new Promise((resolve, reject) => { const transaction = db.transaction(['conversations'], 'readwrite'); const store = transaction.objectStore('conversations'); const getRequest = store.get(id); getRequest.onsuccess = () => { const message = getRequest.result; if (message) { message.content = newContent; const updateRequest = store.put(message); updateRequest.onsuccess = resolve; updateRequest.onerror = reject; } else { reject('æœªæ‰¾åˆ°æ¶ˆæ¯'); } }; getRequest.onerror = reject; }); }
        };

        function blobToDataUrl(blob) { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); }); }
        function resizeAndCompressImage(file, maxWidth = 1024, maxHeight = 1024, quality = 0.7) { return new Promise((resolve, reject) => { const img = new Image(); img.src = URL.createObjectURL(file); img.onload = () => { let width = img.width; let height = img.height; if (width > height) { if (width > maxWidth) { height = Math.round(height * (maxWidth / width)); width = maxWidth; } } else { if (height > maxHeight) { width = Math.round(width * (maxHeight / height)); height = maxHeight; } } const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0, width, height); canvas.toBlob( (blob) => { if (blob) { resolve(blob); } else { reject(new Error('Canvas to Blob conversion failed')); } }, 'image/jpeg', quality ); }; img.onerror = (error) => reject(error); }); }

        // ****** getAIResponse å‡½æ•°çš„æœ€ç»ˆç‰ˆæœ¬ ******
        async function getAIResponse(chatHistory, apiKey, apiEndpoint, apiModel, proxyService, friendData) {

            // 1. å‡†å¤‡AIäººè®¾ (Friend's Persona)
            let systemPrompt = friendData.prompt || 'ä½ æ˜¯ä¸€ä¸ªä¹äºåŠ©äººçš„AIåŠ©æ‰‹ã€‚';

            // 2. å‡†å¤‡ç”¨æˆ·äººè®¾ (User's Persona)
            const allUserPersonas = JSON.parse(localStorage.getItem('userPersonas')) || [];
            const linkedUserPersona = allUserPersonas.find(p => p.id === friendData.linkedPersonaId);
            if (linkedUserPersona) {
                systemPrompt += `\n\n## ä½ çš„å¯¹è¯ä¼™ä¼´äººè®¾ (User Persona)\n${linkedUserPersona.content}`;
            }

            // 3. å‡†å¤‡å·²å…³è”çš„ä¸–ç•Œä¹¦ (Linked World Book)
            const allWorldbookEntries = JSON.parse(localStorage.getItem('hakimi-os-worldbook')) || [];
            const linkedWorldbookIds = friendData.linkedWorldbookIds || [];
            const linkedWorldbookEntries = allWorldbookEntries.filter(entry => linkedWorldbookIds.includes(entry.id));
            if (linkedWorldbookEntries.length > 0) {
                systemPrompt += '\n\n## ä¸–ç•Œä¹¦å‚è€ƒèµ„æ–™ (World Book Reference)\n';
                linkedWorldbookEntries.forEach(entry => {
                    systemPrompt += `### ${entry.title}\n${entry.content}\n\n`;
                });
            }

            // 4. å‡†å¤‡é»˜è®¤çš„ç³»ç»ŸæŒ‡ä»¤
            const defaultSystemPrompt = localStorage.getItem('hakimi-os-system-prompt') || '';
            const finalSystemPrompt = defaultSystemPrompt + '\n\n' + systemPrompt;

            // 5. å‡†å¤‡å¯¹è¯å†å²
            const messagesForAI = [{ role: 'system', content: finalSystemPrompt }];
            for (const msg of chatHistory) {
                if (msg.sender === 'me') {
                    if (msg.type === 'text') {
                        let userContent = msg.content;
                        if (msg.replyTo) {
                            const originalMsg = await DBHelper.getMessageById(msg.replyTo);
                            if (originalMsg) {
                                let quotedText = originalMsg.type === 'text' ? originalMsg.content : `[ä¸€æ¡${originalMsg.type}æ¶ˆæ¯]`;
                                userContent = `[å›å¤"${quotedText}"]: ${userContent}`;
                            }
                        }
                        userContent += ` [msg_id: ${msg.id}]`;
                        messagesForAI.push({ role: 'user', content: userContent });
                    } else if (msg.type === 'image') {
                        try { const imageUrl = await blobToDataUrl(msg.content); messagesForAI.push({ role: 'user', content: [{ type: 'image_url', image_url: { url: imageUrl } }] }); } catch (e) { console.error("å›¾ç‰‡Blobè½¬DataURLå¤±è´¥:", e); }
                    }
                } else {
                     if (msg.tool_use_data) {
                        messagesForAI.push({ role: 'assistant', content: JSON.stringify(msg.tool_use_data) });
                    } else if (msg.type === 'text') {
                        let aiContent = msg.content;
                        if (msg.replyTo) {
                           aiContent = `REPLY_TO(${msg.replyTo}): ${aiContent}`;
                        }
                        messagesForAI.push({ role: 'assistant', content: aiContent });
                    }
                }
            }

            // 6. å‘é€è¯·æ±‚
            statusIndicator.textContent = 'å¯¹æ–¹æ­£åœ¨è¾“å…¥...';
            try {
                let chatEndpoint = apiEndpoint.endsWith('/') ? apiEndpoint.slice(0, -1) : apiEndpoint;
                if (!chatEndpoint.endsWith('/chat/completions')) { chatEndpoint += '/chat/completions'; }
                const encodedUrl = encodeURIComponent(chatEndpoint); const finalUrl = proxyService + encodedUrl;
                const response = await fetch(finalUrl, { method: 'POST', headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` }, body: JSON.stringify({ model: apiModel, messages: messagesForAI, stream: false }) });
                if (!response.ok) { const errorData = await response.text(); throw new Error(`APIè¿”å›é”™è¯¯ (çŠ¶æ€ç : ${response.status}): ${errorData}`); }
                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) { console.error('è°ƒç”¨AIå¤±è´¥:', error); return `(æŠ±æ­‰ï¼ŒAIè¿æ¥å‡ºç°é—®é¢˜: ${error.message}ã€‚è¯·æ£€æŸ¥è®¾ç½®)`; }
            finally { statusIndicator.textContent = 'ğŸŸ¢ åœ¨çº¿'; }
        }

        async function processAIResponse(responseText) { if (!responseText) return; try { const command = JSON.parse(responseText); if (command.tool_use && command.parameters) { let toolMessage = { sender: 'friend', timestamp: Date.now(), tool_use_data: command }; switch (command.tool_use) { case 'reply_with_quote': if (command.parameters.content && command.parameters.quote_id) { toolMessage.type = 'text'; toolMessage.content = command.parameters.content; toolMessage.replyTo = parseInt(command.parameters.quote_id, 10); } break; case 'send_voice': if (command.parameters.content) { toolMessage.type = 'voice'; toolMessage.content = command.parameters.content; toolMessage.duration = Math.max(1, Math.round(command.parameters.content.length / 4)); } break; case 'send_camera': if (command.parameters.description) { toolMessage.type = 'camera'; toolMessage.content = command.parameters.description; } break; case 'send_transfer': if (command.parameters.amount) { toolMessage.type = 'transfer'; toolMessage.content = { amount: parseFloat(command.parameters.amount).toFixed(2), remark: command.parameters.remark || '' }; } break; case 'send_sticker': if (command.parameters.url) { toolMessage.type = 'sticker'; toolMessage.content = command.parameters.url; } break; } if (toolMessage.type) { await sendMessageToScreen(toolMessage); return; } } } catch (e) { } const lines = responseText.split('\n').filter(line => line.trim() !== ''); for (const line of lines) { const aiMessage = { sender: 'friend', content: line.trim(), type: 'text', timestamp: Date.now() }; await sendMessageToScreen(aiMessage); await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200)); } }
        async function initializeChat() { const params = new URLSearchParams(window.location.search); friendId = params.get('friendId'); if (!friendId) { friendNameElement.textContent = 'é”™è¯¯ï¼šæœªæ‰¾åˆ°å¥½å‹'; return; } const allFriends = JSON.parse(localStorage.getItem('friends')) || []; friendData = allFriends.find(f => f.id === friendId); if (!friendData) { friendNameElement.textContent = 'é”™è¯¯ï¼šå¥½å‹ä¸å­˜åœ¨'; return; } userData.avatar = localStorage.getItem('userAvatar') || 'images/default_avatar.png'; userData.nickname = localStorage.getItem('userNickname') || 'æˆ‘'; friendNameElement.textContent = friendData.nickname || friendData.name; document.title = `ä¸ ${friendNameElement.textContent} çš„èŠå¤©`; loadUserStickers(); await renderMessages(); }
        async function renderMessages() { messageArea.innerHTML = ''; lastMessageTimestamp = 0; try { const conversationHistory = await DBHelper.getMessages(friendId); for (const msg of conversationHistory) { await appendMessageToUI(msg, false); } } catch (error) { console.error("æ¸²æŸ“æ¶ˆæ¯å¤±è´¥:", error); } messageArea.scrollTop = messageArea.scrollHeight; }
        function formatTimestamp(ts) { const date = new Date(ts); const month = date.getMonth() + 1; const day = date.getDate(); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${month}.${day} ${hours}:${minutes}`; }
        async function appendMessageToUI(msg, shouldScroll) { const newTimestamp = msg.timestamp; if (lastMessageTimestamp > 0 && (newTimestamp - lastMessageTimestamp > TEN_MINUTES_IN_MS)) { const timestampDiv = document.createElement('div'); timestampDiv.className = 'timestamp-separator'; timestampDiv.textContent = formatTimestamp(newTimestamp); messageArea.appendChild(timestampDiv); } lastMessageTimestamp = newTimestamp; const messageWrapper = document.createElement('div'); messageWrapper.className = 'message-wrapper'; messageWrapper.dataset.id = msg.id; const messageDiv = document.createElement('div'); messageDiv.className = 'message'; const avatarImg = document.createElement('img'); avatarImg.className = 'avatar'; messageDiv.dataset.type = msg.type; if (msg.replyTo) { const originalMsg = await DBHelper.getMessageById(msg.replyTo); if (originalMsg) { const quoteDiv = document.createElement('div'); quoteDiv.className = 'quoted-message'; let quoteContent = ''; if (originalMsg.type === 'text') quoteContent = originalMsg.content; else if (originalMsg.type === 'voice') quoteContent = `[è¯­éŸ³]: ${originalMsg.content}`; else if (originalMsg.type === 'camera') quoteContent = `[ç…§ç‰‡]: ${originalMsg.content}`; else quoteContent = `[ä¸€æ¡${originalMsg.type}æ¶ˆæ¯]`; const authorName = originalMsg.sender === 'me' ? (userData.nickname || 'æˆ‘') : (friendData.nickname || 'æœªçŸ¥'); quoteDiv.innerHTML = `<span class="quoted-author">${authorName}</span><p class="quoted-text">${quoteContent}</p>`; messageDiv.appendChild(quoteDiv); } } if (msg.type === 'text') { messageDiv.classList.add('text'); messageDiv.innerHTML += `<p>${msg.content}</p>`; } else if (msg.type === 'voice') { messageDiv.classList.add('voice'); const waveHTML = `<div class="sound-waves"><span class="bar" style="height: 60%;"></span><span class="bar" style="height: 100%;"></span><span class="bar" style="height: 80%;"></span><span class="bar" style="height: 40%;"></span></div>`; messageDiv.innerHTML += `<div class="voice-display"><svg class="play-icon-svg" viewBox="0 0 8 12"><path d="M0 12L10 6L0 0V12Z"/></svg>${waveHTML}<span class="duration">${msg.duration}"</span></div><div class="transcribed-text"><div class="text-content">${msg.content}</div><div class="collapse-arrow">^</div></div>`; messageDiv.onclick = function(e) { if(e.target.closest('.quoted-message')) return; this.classList.toggle('is-transcribed'); }; } else if (msg.type === 'image') { messageDiv.classList.add('image'); try { const imageUrl = await blobToDataUrl(msg.content); messageDiv.innerHTML += `<img src="${imageUrl}" alt="å‘é€çš„å›¾ç‰‡">`; } catch (e) { messageDiv.innerHTML += `<p>[å›¾ç‰‡åŠ è½½å¤±è´¥]</p>`; } } else if (msg.type === 'camera') { messageDiv.classList.add('camera'); messageDiv.innerHTML += `<div class="camera-placeholder"><p>[${msg.content}]</p></div>`; } else if (msg.type === 'transfer') { messageDiv.classList.add('transfer'); const remarkText = msg.content.remark ? msg.content.remark : 'è½¬è´¦'; const targetName = (msg.sender === 'me') ? (friendData.nickname || friendData.name) : (userData.nickname || 'æˆ‘'); messageDiv.innerHTML += `<div class="transfer-content"><div class="transfer-header"><span>ğŸ’°</span><span>è½¬è´¦ç»™ ${targetName}</span></div><div class="transfer-amount"><small>Â¥</small>${msg.content.amount}</div><div class="transfer-remark">${remarkText}</div></div><div class="transfer-footer">å“ˆåŸºç±³OS è½¬è´¦</div>`; } else if (msg.type === 'sticker') { messageDiv.classList.add('sticker'); messageDiv.innerHTML += `<img src="${msg.content}" alt="è¡¨æƒ…åŒ…">`; } if (msg.sender === 'me') { messageWrapper.classList.add('sent'); avatarImg.src = userData.avatar; messageWrapper.appendChild(messageDiv); messageWrapper.appendChild(avatarImg); } else { messageWrapper.classList.add('received'); avatarImg.src = friendData.avatar || 'images/default_avatar.png'; messageWrapper.appendChild(avatarImg); messageWrapper.appendChild(messageDiv); } messageArea.appendChild(messageWrapper); if (shouldScroll !== false) messageArea.scrollTop = messageArea.scrollHeight; }
        async function sendMessageToScreen(msgObject) { const savedMsg = await DBHelper.addMessage(friendId, msgObject); let lastMessageText; if (savedMsg.type === 'text') { lastMessageText = savedMsg.content; } else { lastMessageText = `[${{voice: 'è¯­éŸ³', image: 'å›¾ç‰‡', camera: 'ç…§ç‰‡', transfer: 'è½¬è´¦', sticker: 'è¡¨æƒ…'}[savedMsg.type]}]`; } updateConversationList(lastMessageText, savedMsg.sender); await appendMessageToUI(savedMsg); }
        function handleTextInput() { const text = messageInput.value.trim(); if (text === '') return; const newMessage = { sender: 'me', content: text, type: 'text', timestamp: Date.now() }; if(replyingToMessageId) { newMessage.replyTo = replyingToMessageId; } sendMessageToScreen(newMessage); messageInput.value = ''; messageInput.style.height = 'auto'; messageInput.focus(); cancelReply(); }
        async function handleTransmitToAI() { const apiKey = localStorage.getItem('hakimi-os-api-key'); const apiEndpoint = localStorage.getItem('hakimi-os-api-endpoint'); const apiModel = localStorage.getItem('hakimi-os-api-model'); const proxyService = localStorage.getItem('hakimi-os-proxy'); if (!apiKey || !apiEndpoint || !apiModel) { await processAIResponse(`(é”™è¯¯: è¯·å…ˆåœ¨ä¸»å±å¹•çš„è®¾ç½®ä¸­å®Œæ•´é…ç½®ä»£ç†ã€API Keyã€ç«¯ç‚¹å’Œæ¨¡å‹ã€‚)`); return; } const history = await DBHelper.getMessages(friendId); const aiReplyText = await getAIResponse(history, apiKey, apiEndpoint, apiModel, proxyService, friendData); await processAIResponse(aiReplyText); }
        async function handleRegenerate() { if (!confirm('ç¡®å®šè¦é‡æ–°ç”ŸæˆAIçš„æœ€æ–°å›å¤å—ï¼Ÿæ­¤æ“ä½œä¼šåˆ é™¤AIçš„æœ€åä¸€è½®æ¶ˆæ¯ã€‚')) return; const history = await DBHelper.getMessages(friendId); if (history.length === 0) return; let lastUserMessageIndex = -1; for (let i = history.length - 1; i >= 0; i--) { if (history[i].sender === 'me') { lastUserMessageIndex = i; break; } } const idsToDelete = []; if (lastUserMessageIndex === history.length - 1) { alert('æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯æ‚¨å‘é€çš„ï¼Œæ²¡æœ‰AIå›å¤å¯ä»¥é‡æ–°ç”Ÿæˆã€‚'); return; } for (let i = lastUserMessageIndex + 1; i < history.length; i++) { idsToDelete.push(history[i].id); } if (idsToDelete.length === 0) { alert('æœªæ‰¾åˆ°å¯é‡æ–°ç”Ÿæˆçš„AIå›å¤ã€‚'); return; } await Promise.all(idsToDelete.map(id => DBHelper.deleteMessage(id))); await renderMessages(); await handleTransmitToAI(); }
        async function handleStartReply() { contextMenu.style.display = 'none'; if (activeMessageId) { replyingToMessageId = activeMessageId; const originalMsg = await DBHelper.getMessageById(replyingToMessageId); if (originalMsg) { let previewText = ''; if (originalMsg.type === 'text') previewText = originalMsg.content; else previewText = `[ä¸€æ¡${originalMsg.type}æ¶ˆæ¯]`; const authorName = originalMsg.sender === 'me' ? (userData.nickname || 'æˆ‘') : (friendData.nickname || 'æœªçŸ¥'); replyPreviewContent.textContent = `${authorName}: ${previewText}`; replyPreview.style.display = 'flex'; messageInput.focus(); } } }
        function cancelReply() { replyingToMessageId = null; replyPreview.style.display = 'none'; }
        function handleVoiceInput() { const text = prompt("è¯·è¾“å…¥è¦è½¬ä¸ºè¯­éŸ³çš„æ¶ˆæ¯å†…å®¹ï¼š"); if (text && text.trim() !== '') { const duration = Math.max(1, Math.round(text.length / 4)); const newMessage = { sender: 'me', content: text.trim(), type: 'voice', duration: duration, timestamp: Date.now() }; sendMessageToScreen(newMessage); } }
        async function handleImageUpload(event) { const file = event.target.files[0]; if (!file) return; try { statusIndicator.textContent = 'æ­£åœ¨å‹ç¼©å›¾ç‰‡...'; const compressedBlob = await resizeAndCompressImage(file); const newMessage = { sender: 'me', content: compressedBlob, type: 'image', timestamp: Date.now() }; await sendMessageToScreen(newMessage); } catch (error) { console.error("å›¾ç‰‡å‹ç¼©å¤±è´¥:", error); alert("å›¾ç‰‡å¤„ç†å¤±è´¥ï¼Œè¯·å°è¯•å…¶ä»–å›¾ç‰‡ã€‚"); } finally { statusIndicator.textContent = 'ğŸŸ¢ åœ¨çº¿'; event.target.value = ''; } }
        function handleCameraInput() { const text = prompt("è¯·ç®€çŸ­æè¿°æ‚¨â€œæ‹æ‘„â€çš„ç…§ç‰‡ï¼š"); if (text && text.trim() !== '') { const newMessage = { sender: 'me', content: text.trim(), type: 'camera', timestamp: Date.now() }; sendMessageToScreen(newMessage); } }
        function handleTransferInput() { transferTitle.textContent = `è½¬è´¦ç»™ ${friendData.nickname || friendData.name}`; transferModal.style.display = 'flex'; }
        function handleConfirmTransfer() { const amount = parseFloat(transferAmountInput.value); const remark = transferRemarkInput.value.trim(); const newMessage = { sender: 'me', content: { amount: amount.toFixed(2), remark: remark || ' ' }, type: 'transfer', timestamp: Date.now() }; sendMessageToScreen(newMessage); transferModal.style.display = 'none'; transferAmountInput.value = ''; transferRemarkInput.value = ''; }
        function validateTransferAmount() { const amount = parseFloat(transferAmountInput.value); if (isNaN(amount) || amount <= 0) { transferError.textContent = 'é‡‘é¢å¿…é¡»å¤§äº0'; confirmTransferBtn.disabled = true; } else if (amount > 50000) { transferError.textContent = 'å•ç¬”è½¬è´¦é‡‘é¢ä¸èƒ½è¶…è¿‡50,000'; confirmTransferBtn.disabled = true; } else { transferError.textContent = ''; confirmTransferBtn.disabled = false; } }
        function updateConversationList(lastMessage, sender) { let conversations = JSON.parse(localStorage.getItem('conversations')) || []; const conversationIndex = conversations.findIndex(c => !c.isGroup && c.friendId === friendId); if (conversationIndex > -1) { const prefix = sender === 'me' ? `` : ``; conversations[conversationIndex].lastMessage = prefix + lastMessage; conversations[conversationIndex].time = new Date().toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); const itemToMove = conversations.splice(conversationIndex, 1)[0]; conversations .unshift(itemToMove); localStorage.setItem('conversations', JSON.stringify(conversations)); } }
        function loadUserStickers() { userStickers = JSON.parse(localStorage.getItem('userStickers')) || []; }
        function saveUserStickers() { localStorage.setItem('userStickers', JSON.stringify(userStickers)); }
        function renderStickerGrid() { stickerGrid.innerHTML = ''; userStickers.forEach(stickerSrc => { const stickerItem = document.createElement('div'); stickerItem.className = 'sticker-item'; stickerItem.innerHTML = `<img src="${stickerSrc}" alt="sticker">`; stickerItem.onclick = () => { sendSticker(stickerSrc); }; stickerGrid.appendChild(stickerItem); }); }
        function handleAddSticker() { const choice = confirm("æ·»åŠ ç½‘ç»œå›¾ç‰‡å—ï¼Ÿ (ç‚¹'å–æ¶ˆ'ä»¥ä¸Šä¼ æœ¬åœ°æ–‡ä»¶)"); if (choice) { const url = prompt("è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥ (URL):"); if (url) { userStickers.push(url); saveUserStickers(); renderStickerGrid(); } } else { stickerUploader.click(); } }
        function handleStickerUpload(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { userStickers.push(e.target.result); saveUserStickers(); renderStickerGrid(); }; reader.readAsDataURL(file); event.target.value = ''; }
        function sendSticker(src) { const newMessage = { sender: 'me', content: src, type: 'sticker', timestamp: Date.now() }; sendMessageToScreen(newMessage); stickerPanel.style.display = 'none'; }
        messageArea.addEventListener('pointerdown', (e) => { const target = e.target.closest('.message-wrapper'); if (!target) return; clearTimeout(longPressTimer); longPressTimer = setTimeout(() => {  activeMessageElement = target; activeMessageId = parseInt(target.dataset.id, 10); const messageType = target.querySelector('.message').dataset.type; editBtn.style.display = ['text', 'voice', 'camera'].includes(messageType) ? 'block' : 'none'; contextMenu.style.left = `${e.clientX}px`; contextMenu.style.top = `${e.clientY}px`; contextMenu.style.display = 'block'; }, 500); });
        messageArea.addEventListener('pointerup', () => clearTimeout(longPressTimer));
        messageArea.addEventListener('pointermove', () => clearTimeout(longPressTimer));
        window.addEventListener('pointerdown', (e) => { if (contextMenu.style.display === 'block' && !contextMenu.contains(e.target)) { contextMenu.style.display = 'none'; } });
        replyBtn.addEventListener('click', handleStartReply);
        closeReplyPreviewBtn.addEventListener('click', cancelReply);
        deleteBtn.addEventListener('click', async () => { contextMenu.style.display = 'none'; if (activeMessageId) { if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯å—ï¼Ÿ')) { await DBHelper.deleteMessage(activeMessageId); await renderMessages(); } } });
        editBtn.addEventListener('click', async () => { contextMenu.style.display = 'none'; if (activeMessageId && activeMessageElement) { const messageDiv = activeMessageElement.querySelector('.message'); const messageType = messageDiv.dataset.type; let currentContent = ''; if (messageType === 'text') { currentContent = messageDiv.querySelector('p').textContent; } else if (messageType === 'voice') { currentContent = messageDiv.querySelector('.text-content').textContent; } else if (messageType === 'camera') { currentContent = messageDiv.querySelector('p').textContent.slice(1, -1); } const newContent = prompt('ç¼–è¾‘æ¶ˆæ¯:', currentContent); if (newContent !== null) { const trimmedContent = newContent.trim(); await DBHelper.updateMessageContent(activeMessageId, trimmedContent); await renderMessages(); } } });
        regenerateBtn.addEventListener('click', handleRegenerate);
        sendButton.addEventListener('click', handleTextInput);
        transmitButton.addEventListener('click', handleTransmitToAI);
        voiceMessageBtn.addEventListener('click', handleVoiceInput);
        imageMessageBtn.addEventListener('click', () => imageUploader.click());
        imageUploader.addEventListener('change', handleImageUpload );
        cameraMessageBtn.addEventListener('click', handleCameraInput);
        transferBtn.addEventListener('click', handleTransferInput);
        cancelTransferBtn.addEventListener('click', () => { transferModal.style.display = 'none'; });
        confirmTransferBtn.addEventListener('click', handleConfirmTransfer);
        emojiBtn.addEventListener('click', () => { renderStickerGrid(); stickerPanel.style.display = 'flex'; });
        closeStickerPanelBtn.addEventListener('click', () => { stickerPanel.style.display = 'none'; });
        addStickerBtn.addEventListener('click', handleAddSticker);
        stickerUploader.addEventListener('change', handleStickerUpload);
        transferAmountInput.addEventListener('input', validateTransferAmount);
        messageInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleTextInput(); } });
        messageInput.addEventListener('input', () => { messageInput.style.height = 'auto'; messageInput.style.height = (messageInput.scrollHeight) + 'px'; sendButton.classList.toggle('active',  messageInput.value.trim() !== ''); });
        initializeChat();
    })();
</script>
</body>
</html>